# progol_definitivo.py
"""
PROGOL DEFINITIVO - La Aplicaci√≥n Completa y Monol√≠tica
=======================================================
Combina lo mejor de QuinielaResults + ProgolNOW
Aplica la Metodolog√≠a Definitiva al pie de la letra
Aplicaci√≥n 100% funcional en un solo archivo
"""

import streamlit as st
import pandas as pd
import numpy as np
import json
import logging
from datetime import datetime
from typing import Dict, List, Any, Optional, Tuple
import copy
import random
import math
from io import BytesIO
import base64

# Configuraci√≥n de la p√°gina
st.set_page_config(
    page_title="üèÜ Progol Definitivo - Metodolog√≠a Real",
    page_icon="‚öΩ",
    layout="wide",
    initial_sidebar_state="expanded"
)

# Configuraci√≥n de logging
logging.basicConfig(level=logging.INFO)

# ===========================
# CONFIGURACI√ìN GLOBAL
# ===========================

PROGOL_CONFIG = {
    "APP_NAME": "Progol Definitivo",
    "APP_VERSION": "2.0.0",
    "METODOLOGIA": "Core + Sat√©lites",
    
    # Distribuci√≥n hist√≥rica
    "DISTRIBUCION_HISTORICA": {
        'L': 0.38,  # 38% victorias locales
        'E': 0.29,  # 29% empates  
        'V': 0.33   # 33% victorias visitantes
    },
    
    # Rangos v√°lidos para validaci√≥n
    "RANGOS_HISTORICOS": {
        'L': (0.35, 0.41),  # Victorias locales: 35-41%
        'E': (0.25, 0.33),  # Empates: 25-33%
        'V': (0.30, 0.36)   # Victorias visitantes: 30-36%
    },
    
    # Configuraci√≥n de empates
    "EMPATES_MIN": 4,
    "EMPATES_MAX": 6,
    "EMPATES_PROMEDIO": 4.33,
    
    # L√≠mites de concentraci√≥n
    "CONCENTRACION_MAX_GENERAL": 0.70,  # 70% m√°ximo en un resultado
    "CONCENTRACION_MAX_INICIAL": 0.60,  # 60% m√°ximo en partidos 1-3
    
    # Calibraci√≥n Bayesiana - Coeficientes LIGEROS
    "CALIBRACION_COEFICIENTES": {
        'k1_forma': 0.05,      # Factor forma reciente (muy bajo)
        'k2_lesiones': 0.03,   # Factor lesiones (muy bajo)
        'k3_contexto': 0.08    # Factor contexto (moderado)
    },
    
    # Clasificaci√≥n de partidos - Umbrales REALISTAS
    "UMBRALES_CLASIFICACION": {
        'ancla_prob_min': 0.50,         # >50% confianza = Ancla (REALISTA)
        'ancla_diferencia_min': 0.08,   # >8% diferencia (REALISTA)
        'divisor_prob_min': 0.35,       # 35-50% = Divisor
        'divisor_prob_max': 0.50,
        'empate_min': 0.35              # >35% prob empate = TendenciaEmpate
    },
    
    # Arquitectura Core + Sat√©lites
    "ARQUITECTURA": {
        'num_core': 4,              # Siempre 4 quinielas Core
        'correlacion_objetivo': -0.35,  # Correlaci√≥n negativa objetivo
        'correlacion_min': -0.50,  # Rango v√°lido de correlaci√≥n
        'correlacion_max': -0.20
    }
}

# ===========================
# CLASES PRINCIPALES
# ===========================

class ClasificadorMejorado:
    """Clasificador que S√ç genera Anclas reales con umbrales realistas"""
    
    def __init__(self):
        self.umbrales = PROGOL_CONFIG["UMBRALES_CLASIFICACION"]
        self.coeficientes = PROGOL_CONFIG["CALIBRACION_COEFICIENTES"]
        self.logger = logging.getLogger(__name__)
    
    def clasificar_partidos(self, partidos: List[Dict]) -> List[Dict]:
        """Clasifica partidos con umbrales REALISTAS que S√ç generan Anclas"""
        partidos_clasificados = []
        
        self.logger.info(f"üîç Clasificando {len(partidos)} partidos...")
        
        for i, partido in enumerate(partidos):
            # Aplicar calibraci√≥n bayesiana LIGERA
            partido_calibrado = self._aplicar_calibracion_ligera(partido)
            
            # Clasificar con umbrales realistas
            clasificacion = self._clasificar_partido(partido_calibrado)
            partido_calibrado['clasificacion'] = clasificacion
            
            self.logger.debug(f"Partido {i+1}: {clasificacion} - Max prob: {max(partido_calibrado['prob_local'], partido_calibrado['prob_empate'], partido_calibrado['prob_visitante']):.3f}")
            
            partidos_clasificados.append(partido_calibrado)
        
        # Mostrar estad√≠sticas
        stats = self._generar_estadisticas(partidos_clasificados)
        self.logger.info(f"üìä Estad√≠sticas: {stats}")
        
        return partidos_clasificados
    
    def _aplicar_calibracion_ligera(self, partido: Dict) -> Dict:
        """Calibraci√≥n bayesiana LIGERA para preservar probabilidades altas"""
        
        # Factores contextuales muy peque√±os para no destruir Anclas
        k1, k2, k3 = self.coeficientes['k1_forma'], self.coeficientes['k2_lesiones'], self.coeficientes['k3_contexto']
        
        forma_factor = 1 + k1 * partido.get('forma_diferencia', 0)
        lesiones_factor = 1 + k2 * partido.get('lesiones_impact', 0)
        contexto_factor = 1 + k3 * (
            0.15 * partido.get('es_final', False) +
            0.10 * partido.get('es_derbi', False) +
            0.12 * partido.get('es_playoff', False)
        )
        
        # Aplicar factores de forma conservadora
        p_local = partido['prob_local'] * forma_factor * contexto_factor
        p_empate = partido['prob_empate'] * (1 + lesiones_factor * 0.5)  # Empates menos afectados
        p_visitante = partido['prob_visitante'] * forma_factor * contexto_factor
        
        # Normalizar manteniendo proporciones
        total = p_local + p_empate + p_visitante
        
        return {
            **partido,
            'prob_local': p_local / total,
            'prob_empate': p_empate / total,
            'prob_visitante': p_visitante / total,
            'calibrado': True,
            'factor_calibracion': total  # Para debug
        }
    
    def _clasificar_partido(self, partido: Dict) -> str:
        """Clasificaci√≥n con umbrales REALISTAS (50% no 60%)"""
        probs = [partido['prob_local'], partido['prob_empate'], partido['prob_visitante']]
        max_prob = max(probs)
        prob_empate = partido['prob_empate']
        
        # ANCLA: >50% (no 60%) + diferencia >8% (no 10%)
        if max_prob > self.umbrales['ancla_prob_min']:
            probs_sorted = sorted(probs, reverse=True)
            diferencia = probs_sorted[0] - probs_sorted[1]
            if diferencia > self.umbrales['ancla_diferencia_min']:
                return "Ancla"
        
        # TENDENCIA EMPATE: >35% empate Y equilibrio L/V
        if prob_empate > self.umbrales['empate_min']:
            prob_local = partido['prob_local']
            prob_visitante = partido['prob_visitante']
            if abs(prob_local - prob_visitante) < 0.15:  # L y V relativamente equilibrados
                return "TendenciaEmpate"
        
        # DIVISOR: Entre 35% y 50% o casos especiales
        if (self.umbrales['divisor_prob_min'] < max_prob <= self.umbrales['divisor_prob_max'] or 
            self._tiene_volatilidad(partido)):
            return "Divisor"
        
        # NEUTRO: Todo lo dem√°s
        return "Neutro"
    
    def _tiene_volatilidad(self, partido: Dict) -> bool:
        """Detecta volatilidad que califica como Divisor"""
        # Si las tres probabilidades est√°n muy equilibradas
        probs = [partido['prob_local'], partido['prob_empate'], partido['prob_visitante']]
        probs_sorted = sorted(probs, reverse=True)
        
        # Si la diferencia entre 1ra y 3ra es peque√±a, es vol√°til
        if (probs_sorted[0] - probs_sorted[2]) < 0.20:
            return True
        
        # Si hay ajustes por calibraci√≥n significativos
        if abs(partido.get('factor_calibracion', 1.0) - 1.0) > 0.10:
            return True
        
        return False
    
    def _generar_estadisticas(self, partidos_clasificados: List[Dict]) -> Dict:
        """Genera estad√≠sticas de clasificaci√≥n"""
        clasificaciones = {}
        for partido in partidos_clasificados:
            clase = partido.get("clasificacion", "Sin clasificar")
            clasificaciones[clase] = clasificaciones.get(clase, 0) + 1
        
        total = len(partidos_clasificados)
        return {
            "total_partidos": total,
            "distribuci√≥n": clasificaciones,
            "porcentajes": {clase: (count/total)*100 for clase, count in clasificaciones.items()}
        }

class GeneradorPortafolio:
    """Generador que S√ç crea quinielas v√°lidas usando arquitectura Core + Sat√©lites"""
    
    def __init__(self):
        self.max_intentos = 100
        self.config = PROGOL_CONFIG
        self.reglas = {
            'empates_min': self.config['EMPATES_MIN'],
            'empates_max': self.config['EMPATES_MAX'],
            'concentracion_max': self.config['CONCENTRACION_MAX_GENERAL'],
            'concentracion_inicial_max': self.config['CONCENTRACION_MAX_INICIAL']
        }
        self.logger = logging.getLogger(__name__)
    
    def generar_portafolio_completo(self, partidos_regular: List[Dict], 
                                   partidos_revancha: List[Dict] = None,
                                   num_quinielas_regular: int = 30,
                                   num_quinielas_revancha: int = 15) -> Dict:
        """Genera portafolio completo: Regular + Revancha (si aplica)"""
        
        self.logger.info("üéØ Iniciando generaci√≥n de portafolio completo...")
        
        # Verificar que tenemos suficientes Anclas
        anclas = [p for p in partidos_regular if p['clasificacion'] == 'Ancla']
        if len(anclas) < 6:
            self.logger.error(f"‚ùå Solo {len(anclas)} Anclas detectadas. Necesitamos al menos 6.")
            return None
        
        self.logger.info(f"‚úÖ {len(anclas)} Anclas detectadas - Generando portafolio...")
        
        # Generar quinielas regulares
        quinielas_regular = self._generar_quinielas_optimizadas(
            partidos_regular, 
            num_quinielas_regular,
            "Regular"
        )
        
        resultado = {
            'partidos_regular': partidos_regular,
            'quinielas_regular': quinielas_regular,
            'resumen': {
                'anclas_detectadas': len(anclas),
                'quinielas_generadas': len(quinielas_regular),
                'tipo': 'Regular',
                'empates_promedio': sum(q['empates'] for q in quinielas_regular) / len(quinielas_regular)
            }
        }
        
        # Si hay partidos de revancha, generar tambi√©n
        if partidos_revancha and len(partidos_revancha) >= 7:
            self.logger.info("üèÜ Generando quinielas de revancha...")
            quinielas_revancha = self._generar_quinielas_optimizadas(
                partidos_revancha[:7], 
                num_quinielas_revancha,
                "Revancha"
            )
            
            resultado['partidos_revancha'] = partidos_revancha[:7]
            resultado['quinielas_revancha'] = quinielas_revancha
            resultado['resumen']['tipo'] = 'Regular + Revancha'
            resultado['resumen']['quinielas_revancha'] = len(quinielas_revancha)
            resultado['resumen']['empates_promedio_revancha'] = sum(q['empates'] for q in quinielas_revancha) / len(quinielas_revancha)
        
        self.logger.info("‚úÖ Portafolio generado exitosamente")
        return resultado
    
    def _generar_quinielas_optimizadas(self, partidos: List[Dict], num_quinielas: int, tipo_concurso: str) -> List[Dict]:
        """Genera quinielas usando arquitectura Core + Sat√©lites mejorada"""
        
        self.logger.info(f"üîß Generando {num_quinielas} quinielas para {tipo_concurso}...")
        
        # PASO 1: Generar 4 quinielas Core (base estable)
        quinielas_core = self._generar_core(partidos, tipo_concurso)
        self.logger.info(f"‚úÖ {len(quinielas_core)} quinielas Core generadas")
        
        # PASO 2: Generar sat√©lites en pares anticorrelados
        num_satelites = num_quinielas - 4
        quinielas_satelites = self._generar_satelites(partidos, quinielas_core, num_satelites, tipo_concurso)
        self.logger.info(f"‚úÖ {len(quinielas_satelites)} quinielas Sat√©lite generadas")
        
        # PASO 3: Combinar y corregir
        todas_quinielas = quinielas_core + quinielas_satelites
        
        # PASO 4: Correcci√≥n autom√°tica inteligente
        quinielas_corregidas = self._corregir_automaticamente(todas_quinielas, partidos)
        self.logger.info(f"‚úÖ {len(quinielas_corregidas)} quinielas corregidas y validadas")
        
        return quinielas_corregidas[:num_quinielas]
    
    def _generar_core(self, partidos: List[Dict], tipo_concurso: str) -> List[Dict]:
        """Genera 4 quinielas Core (base estable y confiable)"""
        quinielas_core = []
        
        for i in range(4):
            quiniela_id = f"Core-{tipo_concurso[0]}{i+1}"  # Core-R1, Core-R2, etc.
            quiniela = self._crear_quiniela_base(partidos, quiniela_id, i)
            quinielas_core.append(quiniela)
        
        return quinielas_core
    
    def _generar_satelites(self, partidos: List[Dict], cores: List[Dict], num_satelites: int, tipo_concurso: str) -> List[Dict]:
        """Genera sat√©lites en pares anticorrelados"""
        satelites = []
        
        # Generar en pares anticorrelados
        num_pares = num_satelites // 2
        for par in range(num_pares):
            sat_a, sat_b = self._crear_par_anticorrelado(partidos, cores, par, tipo_concurso)
            satelites.extend([sat_a, sat_b])
        
        # Si n√∫mero impar, generar uno adicional
        if num_satelites % 2 == 1:
            sat_extra = self._crear_satelite_individual(partidos, cores, len(satelites), tipo_concurso)
            satelites.append(sat_extra)
        
        return satelites
    
    def _crear_quiniela_base(self, partidos: List[Dict], quiniela_id: str, variacion: int) -> Dict:
        """Crea una quiniela base siguiendo la metodolog√≠a exacta"""
        resultados = []
        
        for i, partido in enumerate(partidos):
            clasificacion = partido['clasificacion']
            
            if clasificacion == 'Ancla':
                # ANCLAS: Siempre el resultado m√°s probable (nunca cambia)
                probs = [partido['prob_local'], partido['prob_empate'], partido['prob_visitante']]
                resultado = ['L', 'E', 'V'][np.argmax(probs)]
            
            elif clasificacion == 'TendenciaEmpate':
                # TENDENCIA EMPATE: Favorecer empate con probabilidad alta
                if np.random.random() < 0.75:  # 75% de probabilidad de empate
                    resultado = 'E'
                else:
                    # Si no empate, elegir entre L/V seg√∫n probabilidades
                    if partido['prob_local'] > partido['prob_visitante']:
                        resultado = 'L'
                    else:
                        resultado = 'V'
            
            else:  # Divisor o Neutro
                # Usar probabilidades con ligero sesgo al favorito
                probs = np.array([partido['prob_local'], partido['prob_empate'], partido['prob_visitante']])
                
                # Aplicar variaci√≥n entre Cores
                if variacion > 0:
                    # A√±adir peque√±a variaci√≥n para diversificar Cores
                    noise = np.random.normal(0, 0.05, 3)
                    probs = probs + noise
                    probs = np.maximum(probs, 0.01)  # Evitar probabilidades negativas
                
                # Acentuar favorito (hacer m√°s determin√≠stico)
                probs = probs ** 1.3
                probs = probs / probs.sum()
                
                resultado = np.random.choice(['L', 'E', 'V'], p=probs)
            
            resultados.append(resultado)
        
        # Ajustar empates para cumplir regla 4-6
        resultados = self._ajustar_empates_inteligente(resultados, partidos)
        
        # Crear objeto quiniela
        return self._crear_objeto_quiniela(quiniela_id, resultados, 'Core')
    
    def _crear_par_anticorrelado(self, partidos: List[Dict], cores: List[Dict], par_id: int, tipo_concurso: str) -> Tuple[Dict, Dict]:
        """Crea par de sat√©lites con correlaci√≥n negativa controlada"""
        
        # Partir de base Core para mantener estabilidad
        base_core = cores[par_id % 4]
        resultados_base = base_core['resultados'].copy()
        
        # Crear dos variaciones anticorreladas
        resultados_a = resultados_base.copy()
        resultados_b = resultados_base.copy()
        
        # Identificar partidos modificables (No-Ancla)
        modificables = [i for i, p in enumerate(partidos) if p['clasificacion'] != 'Ancla']
        
        # Crear anticorrelaci√≥n en 3-5 partidos clave
        num_cambios = min(5, len(modificables))
        partidos_cambio = np.random.choice(modificables, num_cambios, replace=False)
        
        for i in partidos_cambio:
            resultado_actual = resultados_a[i]
            
            # Estrategia de anticorrelaci√≥n
            if resultado_actual == 'L':
                resultados_b[i] = 'V' if np.random.random() < 0.7 else 'E'
            elif resultado_actual == 'V':
                resultados_b[i] = 'L' if np.random.random() < 0.7 else 'E'
            else:  # Era 'E'
                # Si era empate, cambiar a L o V seg√∫n probabilidades del partido
                if partidos[i]['prob_local'] > partidos[i]['prob_visitante']:
                    resultados_b[i] = 'L' if np.random.random() < 0.6 else 'V'
                else:
                    resultados_b[i] = 'V' if np.random.random() < 0.6 else 'L'
        
        # Ajustar empates en ambas quinielas
        resultados_a = self._ajustar_empates_inteligente(resultados_a, partidos)
        resultados_b = self._ajustar_empates_inteligente(resultados_b, partidos)
        
        # Crear objetos quiniela
        quiniela_a = self._crear_objeto_quiniela(f"Sat-{tipo_concurso[0]}{par_id+1}A", resultados_a, 'Satelite')
        quiniela_b = self._crear_objeto_quiniela(f"Sat-{tipo_concurso[0]}{par_id+1}B", resultados_b, 'Satelite')
        
        return quiniela_a, quiniela_b
    
    def _crear_satelite_individual(self, partidos: List[Dict], cores: List[Dict], index: int, tipo_concurso: str) -> Dict:
        """Crea un sat√©lite individual con variaci√≥n moderada"""
        base = cores[index % 4]['resultados'].copy()
        
        # Aplicar variaci√≥n moderada en partidos No-Ancla
        modificables = [i for i, p in enumerate(partidos) if p['clasificacion'] != 'Ancla']
        
        # Cambiar 20-30% de los partidos modificables
        num_cambios = max(1, int(len(modificables) * 0.25))
        partidos_cambio = np.random.choice(modificables, num_cambios, replace=False)
        
        for i in partidos_cambio:
            opciones = ['L', 'E', 'V']
            opciones.remove(base[i])
            base[i] = np.random.choice(opciones)
        
        base = self._ajustar_empates_inteligente(base, partidos)
        return self._crear_objeto_quiniela(f"Sat-{tipo_concurso[0]}{index+1}", base, 'Satelite')
    
    def _ajustar_empates_inteligente(self, resultados: List[str], partidos: List[Dict]) -> List[str]:
        """Ajusta empates de forma inteligente respetando Anclas y probabilidades"""
        empates_actuales = resultados.count('E')
        
        # Si est√° en rango, no hacer nada
        if self.reglas['empates_min'] <= empates_actuales <= self.reglas['empates_max']:
            return resultados
        
        # Identificar partidos modificables (No-Ancla)
        modificables = [(i, p) for i, p in enumerate(partidos) if p['clasificacion'] != 'Ancla']
        
        if empates_actuales < self.reglas['empates_min']:
            # AGREGAR empates: cambiar L/V a E en partidos con mayor prob_empate
            faltantes = self.reglas['empates_min'] - empates_actuales
            candidatos = [(i, p['prob_empate']) for i, p in modificables 
                         if resultados[i] != 'E']
            candidatos.sort(key=lambda x: x[1], reverse=True)  # Ordenar por mayor prob_empate
            
            for i, _ in candidatos[:faltantes]:
                resultados[i] = 'E'
        
        elif empates_actuales > self.reglas['empates_max']:
            # QUITAR empates: cambiar E a L/V en partidos con menor prob_empate
            exceso = empates_actuales - self.reglas['empates_max']
            candidatos = [(i, p['prob_empate']) for i, p in modificables 
                         if resultados[i] == 'E']
            candidatos.sort(key=lambda x: x[1])  # Ordenar por menor prob_empate
            
            for i, _ in candidatos[:exceso]:
                # Cambiar a L o V seg√∫n probabilidades
                partido = partidos[i]
                if partido['prob_local'] > partido['prob_visitante']:
                    resultados[i] = 'L'
                else:
                    resultados[i] = 'V'
        
        return resultados
    
    def _crear_objeto_quiniela(self, quiniela_id: str, resultados: List[str], tipo: str) -> Dict:
        """Crea objeto quiniela con metadata completa"""
        empates = resultados.count('E')
        
        # Calcular probabilidad estimada de ‚â•11 (simplificada)
        prob_11_plus = self._estimar_probabilidad_11_plus(resultados)
        
        return {
            'id': quiniela_id,
            'tipo': tipo,
            'resultados': resultados,
            'empates': empates,
            'distribucion': {
                'L': resultados.count('L'),
                'E': empates,
                'V': resultados.count('V')
            },
            'prob_11_plus': prob_11_plus,
            'valida': self._es_quiniela_basicamente_valida(resultados),
            'generacion_timestamp': datetime.now().isoformat()
        }
    
    def _estimar_probabilidad_11_plus(self, resultados: List[str]) -> float:
        """Estimaci√≥n r√°pida de probabilidad ‚â•11 aciertos"""
        # Simulaci√≥n Monte Carlo simplificada
        prob_base = 0.45  # Probabilidad promedio de acierto
        
        # Ajustar seg√∫n distribuci√≥n de empates
        empates = resultados.count('E')
        if empates >= 5:
            prob_base += 0.02  # Empates suelen ser m√°s predecibles
        
        # Simulaci√≥n binomial aproximada
        n_simulaciones = 1000
        aciertos_11_plus = 0
        
        for _ in range(n_simulaciones):
            aciertos = np.random.binomial(14, prob_base)
            if aciertos >= 11:
                aciertos_11_plus += 1
        
        return aciertos_11_plus / n_simulaciones
    
    def _es_quiniela_basicamente_valida(self, resultados: List[str]) -> bool:
        """Verificaci√≥n b√°sica de validez"""
        empates = resultados.count('E')
        
        # Regla b√°sica: empates en rango
        if not (self.reglas['empates_min'] <= empates <= self.reglas['empates_max']):
            return False
        
        # Regla b√°sica: no concentraci√≥n extrema
        for signo in ['L', 'E', 'V']:
            if resultados.count(signo) > 10:  # >71% es demasiado
                return False
        
        return True
    
    def _corregir_automaticamente(self, quinielas: List[Dict], partidos: List[Dict]) -> List[Dict]:
        """Sistema inteligente de correcci√≥n autom√°tica"""
        quinielas_corregidas = []
        correcciones_realizadas = 0
        
        for quiniela in quinielas:
            if self._es_quiniela_valida_completa(quiniela):
                quinielas_corregidas.append(quiniela)
            else:
                quiniela_corregida = self._corregir_quiniela_inteligente(quiniela, partidos)
                quinielas_corregidas.append(quiniela_corregida)
                correcciones_realizadas += 1
        
        if correcciones_realizadas > 0:
            self.logger.info(f"üîß {correcciones_realizadas} quinielas corregidas autom√°ticamente")
        
        return quinielas_corregidas
    
    def _es_quiniela_valida_completa(self, quiniela: Dict) -> bool:
        """Validaci√≥n completa seg√∫n todas las reglas"""
        empates = quiniela['empates']
        resultados = quiniela['resultados']
        
        # Regla 1: Empates en rango 4-6
        if not (self.reglas['empates_min'] <= empates <= self.reglas['empates_max']):
            return False
        
        # Regla 2: Concentraci√≥n m√°xima ‚â§70%
        max_count = max(quiniela['distribucion'].values())
        if max_count > 9:  # 9/14 = 64%, margen de seguridad
            return False
        
        # Regla 3: Concentraci√≥n inicial ‚â§60%
        primeros_3 = resultados[:3]
        for signo in ['L', 'E', 'V']:
            if primeros_3.count(signo) > 2:  # 2/3 = 67%, margen de seguridad
                return False
        
        return True
    
    def _corregir_quiniela_inteligente(self, quiniela: Dict, partidos: List[Dict]) -> Dict:
        """Correcci√≥n inteligente que respeta Anclas y probabilidades"""
        resultados = quiniela['resultados'].copy()
        
        # Identificar partidos modificables
        modificables = [i for i, p in enumerate(partidos) if p['clasificacion'] != 'Ancla']
        
        # Corregir empates primero
        empates_actuales = resultados.count('E')
        
        if empates_actuales < self.reglas['empates_min']:
            # Agregar empates en partidos con alta prob_empate
            faltantes = self.reglas['empates_min'] - empates_actuales
            candidatos = [(i, partidos[i]['prob_empate']) for i in modificables 
                         if resultados[i] != 'E']
            candidatos.sort(key=lambda x: x[1], reverse=True)
            
            for i, _ in candidatos[:faltantes]:
                resultados[i] = 'E'
        
        elif empates_actuales > self.reglas['empates_max']:
            # Quitar empates en partidos con baja prob_empate
            exceso = empates_actuales - self.reglas['empates_max']
            candidatos = [(i, partidos[i]['prob_empate']) for i in modificables 
                         if resultados[i] == 'E']
            candidatos.sort(key=lambda x: x[1])
            
            for i, _ in candidatos[:exceso]:
                if partidos[i]['prob_local'] > partidos[i]['prob_visitante']:
                    resultados[i] = 'L'
                else:
                    resultados[i] = 'V'
        
        # Corregir concentraci√≥n si es necesaria
        for signo in ['L', 'E', 'V']:
            count = resultados.count(signo)
            if count > 9:  # Demasiada concentraci√≥n
                exceso = count - 9
                indices_signo = [i for i in modificables if resultados[i] == signo]
                
                # Cambiar los que tienen menor probabilidad de ese signo
                candidatos = [(i, self._get_prob_signo(partidos[i], signo)) for i in indices_signo]
                candidatos.sort(key=lambda x: x[1])
                
                for i, _ in candidatos[:exceso]:
                    # Cambiar al signo m√°s probable (que no sea el actual)
                    p = partidos[i]
                    probs = {'L': p['prob_local'], 'E': p['prob_empate'], 'V': p['prob_visitante']}
                    del probs[signo]
                    nuevo_signo = max(probs, key=probs.get)
                    resultados[i] = nuevo_signo
        
        # Crear nueva quiniela corregida
        return self._crear_objeto_quiniela(quiniela['id'] + "_corr", resultados, quiniela['tipo'])
    
    def _get_prob_signo(self, partido: Dict, signo: str) -> float:
        """Obtiene la probabilidad de un signo espec√≠fico"""
        mapping = {'L': 'prob_local', 'E': 'prob_empate', 'V': 'prob_visitante'}
        return partido[mapping[signo]]

class ValidadorCompleto:
    """Validador que da retroalimentaci√≥n √∫til y diagn√≥sticos detallados"""
    
    def __init__(self):
        self.config = PROGOL_CONFIG
        self.logger = logging.getLogger(__name__)
    
    def validar_portafolio(self, quinielas: List[Dict], tipo: str = "Regular") -> Dict:
        """Validaci√≥n completa con diagn√≥sticos detallados"""
        
        self.logger.info(f"üîç Validando portafolio {tipo} con {len(quinielas)} quinielas...")
        
        # Ejecutar todas las validaciones
        reglas = {
            'empates_individuales': self._validar_empates_individuales(quinielas),
            'distribucion_global': self._validar_distribucion_global(quinielas),
            'concentracion_maxima': self._validar_concentracion_maxima(quinielas),
            'arquitectura': self._validar_arquitectura(quinielas),
            'correlacion_satelites': self._validar_correlacion_satelites(quinielas),
            'equilibrio_distribucional': self._validar_equilibrio_distribucional(quinielas)
        }
        
        # Calcular estado general
        es_valido = all(reglas.values())
        num_reglas_cumplidas = sum(reglas.values())
        
        resultado = {
            'es_valido': es_valido,
            'reglas_cumplidas': f"{num_reglas_cumplidas}/{len(reglas)}",
            'reglas': reglas,
            'diagnostico': self._generar_diagnostico_detallado(quinielas, reglas),
            'metricas': self._calcular_metricas_completas(quinielas),
            'recomendaciones': self._generar_recomendaciones(quinielas, reglas)
        }
        
        estado = "‚úÖ V√ÅLIDO" if es_valido else f"‚ö†Ô∏è PARCIAL ({num_reglas_cumplidas}/{len(reglas)})"
        self.logger.info(f"üìä Validaci√≥n {tipo}: {estado}")
        
        return resultado
    
    def _validar_empates_individuales(self, quinielas: List[Dict]) -> bool:
        """Regla 1: Cada quiniela debe tener 4-6 empates"""
        min_empates = self.config['EMPATES_MIN']
        max_empates = self.config['EMPATES_MAX']
        
        for quiniela in quinielas:
            empates = quiniela['empates']
            if not (min_empates <= empates <= max_empates):
                return False
        
        return True
    
    def _validar_distribucion_global(self, quinielas: List[Dict]) -> bool:
        """Regla 2: Distribuci√≥n global en rangos hist√≥ricos"""
        total_partidos = len(quinielas) * 14
        
        total_L = sum(q['distribucion']['L'] for q in quinielas)
        total_E = sum(q['distribucion']['E'] for q in quinielas)
        total_V = sum(q['distribucion']['V'] for q in quinielas)
        
        porc_L = total_L / total_partidos
        porc_E = total_E / total_partidos
        porc_V = total_V / total_partidos
        
        rangos = self.config['RANGOS_HISTORICOS']
        
        return (rangos['L'][0] <= porc_L <= rangos['L'][1] and 
                rangos['E'][0] <= porc_E <= rangos['E'][1] and 
                rangos['V'][0] <= porc_V <= rangos['V'][1])
    
    def _validar_concentracion_maxima(self, quinielas: List[Dict]) -> bool:
        """Regla 3: Concentraci√≥n ‚â§70% general, ‚â§60% inicial"""
        for quiniela in quinielas:
            # Concentraci√≥n general
            max_count = max(quiniela['distribucion'].values())
            if max_count > 9:  # 9/14 ‚âà 64%
                return False
            
            # Concentraci√≥n inicial (primeros 3 partidos)
            primeros_3 = quiniela['resultados'][:3]
            for signo in ['L', 'E', 'V']:
                if primeros_3.count(signo) > 2:  # 2/3 ‚âà 67%
                    return False
        
        return True
    
    def _validar_arquitectura(self, quinielas: List[Dict]) -> bool:
        """Regla 4: Arquitectura Core + Sat√©lites (4 + N)"""
        cores = [q for q in quinielas if q['tipo'] == 'Core']
        satelites = [q for q in quinielas if q['tipo'] == 'Satelite']
        
        # Debe haber exactamente 4 Cores
        if len(cores) != 4:
            return False
        
        # Debe haber al menos 20 sat√©lites para un portafolio de 30
        if len(satelites) < 20:
            return False
        
        return True
    
    def _validar_correlacion_satelites(self, quinielas: List[Dict]) -> bool:
        """Regla 5: Correlaci√≥n entre sat√©lites no debe ser muy alta"""
        satelites = [q for q in quinielas if q['tipo'] == 'Satelite']
        
        if len(satelites) < 2:
            return True  # No aplica si hay pocos sat√©lites
        
        # Verificar correlaci√≥n promedio
        correlaciones = []
        for i in range(len(satelites)):
            for j in range(i + 1, len(satelites)):
                corr = self._calcular_correlacion_jaccard(satelites[i]['resultados'], satelites[j]['resultados'])
                correlaciones.append(corr)
        
        if correlaciones:
            correlacion_promedio = sum(correlaciones) / len(correlaciones)
            return correlacion_promedio <= 0.65  # Umbral relajado
        
        return True
    
    def _validar_equilibrio_distribucional(self, quinielas: List[Dict]) -> bool:
        """Regla 6: No debe haber dominancia excesiva de un resultado"""
        total_partidos = len(quinielas) * 14
        
        total_L = sum(q['distribucion']['L'] for q in quinielas)
        total_E = sum(q['distribucion']['E'] for q in quinielas)
        total_V = sum(q['distribucion']['V'] for q in quinielas)
        
        # Ning√∫n resultado debe superar el 50%
        max_resultado = max(total_L, total_E, total_V)
        return max_resultado <= (total_partidos * 0.50)
    
    def _calcular_correlacion_jaccard(self, resultados1: List[str], resultados2: List[str]) -> float:
        """Calcula correlaci√≥n Jaccard entre dos quinielas"""
        coincidencias = sum(1 for r1, r2 in zip(resultados1, resultados2) if r1 == r2)
        return coincidencias / 14
    
    def _generar_diagnostico_detallado(self, quinielas: List[Dict], reglas: Dict) -> str:
        """Genera diagn√≥stico detallado con problemas espec√≠ficos"""
        diagnostico = []
        
        if not reglas['empates_individuales']:
            problematicas = [q for q in quinielas if not (4 <= q['empates'] <= 6)]
            diagnostico.append(f"‚ùå EMPATES: {len(problematicas)} quinielas fuera del rango 4-6")
            for q in problematicas[:3]:  # Mostrar solo las primeras 3
                diagnostico.append(f"   ‚Ä¢ {q['id']}: {q['empates']} empates")
        
        if not reglas['distribucion_global']:
            total_partidos = len(quinielas) * 14
            total_L = sum(q['distribucion']['L'] for q in quinielas)
            total_E = sum(q['distribucion']['E'] for q in quinielas)
            total_V = sum(q['distribucion']['V'] for q in quinielas)
            
            diagnostico.append("‚ùå DISTRIBUCI√ìN GLOBAL fuera de rangos hist√≥ricos:")
            diagnostico.append(f"   ‚Ä¢ L: {total_L/total_partidos:.1%} (objetivo: 35-41%)")
            diagnostico.append(f"   ‚Ä¢ E: {total_E/total_partidos:.1%} (objetivo: 25-33%)")
            diagnostico.append(f"   ‚Ä¢ V: {total_V/total_partidos:.1%} (objetivo: 30-36%)")
        
        if not reglas['concentracion_maxima']:
            concentradas = []
            for q in quinielas:
                max_count = max(q['distribucion'].values())
                if max_count > 9:
                    signo = max(q['distribucion'], key=q['distribucion'].get)
                    concentradas.append(f"{q['id']}: {signo}={max_count}/14")
            
            if concentradas:
                diagnostico.append(f"‚ùå CONCENTRACI√ìN: {len(concentradas)} quinielas con >70%")
                for conc in concentradas[:3]:
                    diagnostico.append(f"   ‚Ä¢ {conc}")
        
        if not reglas['arquitectura']:
            cores = len([q for q in quinielas if q['tipo'] == 'Core'])
            satelites = len([q for q in quinielas if q['tipo'] == 'Satelite'])
            diagnostico.append(f"‚ùå ARQUITECTURA: {cores} Core, {satelites} Sat√©lites (necesita 4 Core)")
        
        if not diagnostico:
            diagnostico.append("‚úÖ Todas las reglas se cumplen correctamente")
            diagnostico.append("üéâ Portafolio listo para jugar")
        
        return "\n".join(diagnostico)
    
    def _calcular_metricas_completas(self, quinielas: List[Dict]) -> Dict:
        """Calcula m√©tricas completas del portafolio"""
        total_partidos = len(quinielas) * 14
        total_L = sum(q['distribucion']['L'] for q in quinielas)
        total_E = sum(q['distribucion']['E'] for q in quinielas)
        total_V = sum(q['distribucion']['V'] for q in quinielas)
        
        # Estad√≠sticas de empates
        empates_por_quiniela = [q['empates'] for q in quinielas]
        
        # Estad√≠sticas de probabilidad ‚â•11
        probs_11_plus = [q.get('prob_11_plus', 0) for q in quinielas]
        
        return {
            'total_quinielas': len(quinielas),
            'total_partidos': total_partidos,
            'distribucion_global': {
                'L_count': total_L,
                'E_count': total_E,
                'V_count': total_V,
                'L_porc': f"{total_L/total_partidos:.1%}",
                'E_porc': f"{total_E/total_partidos:.1%}",
                'V_porc': f"{total_V/total_partidos:.1%}"
            },
            'empates_estadisticas': {
                'promedio': sum(empates_por_quiniela) / len(empates_por_quiniela),
                'minimo': min(empates_por_quiniela),
                'maximo': max(empates_por_quiniela),
                'fuera_rango': len([e for e in empates_por_quiniela if not (4 <= e <= 6)])
            },
            'arquitectura': {
                'cores': len([q for q in quinielas if q['tipo'] == 'Core']),
                'satelites': len([q for q in quinielas if q['tipo'] == 'Satelite'])
            },
            'probabilidad_11_plus': {
                'promedio': sum(probs_11_plus) / len(probs_11_plus) if probs_11_plus else 0,
                'maximo': max(probs_11_plus) if probs_11_plus else 0
            }
        }
    
    def _generar_recomendaciones(self, quinielas: List[Dict], reglas: Dict) -> List[str]:
        """Genera recomendaciones espec√≠ficas para mejorar"""
        recomendaciones = []
        
        if not reglas['empates_individuales']:
            recomendaciones.append("üîß Ajustar quinielas con empates fuera del rango 4-6")
            recomendaciones.append("üí° Priorizar partidos con alta probabilidad de empate")
        
        if not reglas['distribucion_global']:
            recomendaciones.append("‚öñÔ∏è Rebalancear distribuci√≥n global hacia rangos hist√≥ricos")
            recomendaciones.append("üéØ Verificar calibraci√≥n de probabilidades base")
        
        if not reglas['concentracion_maxima']:
            recomendaciones.append("üìä Diversificar resultados en quinielas concentradas")
            recomendaciones.append("üîÑ Usar m√°s partidos Divisor para variaci√≥n")
        
        if not reglas['arquitectura']:
            recomendaciones.append("üèóÔ∏è Corregir arquitectura Core + Sat√©lites")
            recomendaciones.append("üìê Mantener exactamente 4 quinielas Core")
        
        if all(reglas.values()):
            recomendaciones.append("üéâ Portafolio optimal - listo para imprimir")
            recomendaciones.append("üí∞ Probabilidad estimada de premio mejorada")
        
        return recomendaciones

# ===========================
# GENERADOR DE DATOS REALISTAS
# ===========================

def generar_datos_ejemplo_extremos():
    """Genera datos de ejemplo que GARANTIZAN Anclas despu√©s de calibraci√≥n"""
    
    # Equipos con probabilidades EXTREMAS para sobrevivir calibraci√≥n
    equipos_regular = [
        # ANCLAS S√öPER FUERTES (>75% probabilidad)
        ("Manchester City", "Sheffield United", "Premier League", {'tipo': 'ancla_local_extrema', 'prob_local': 0.78}),
        ("Real Madrid", "Almer√≠a", "La Liga", {'tipo': 'ancla_local_extrema', 'prob_local': 0.76}),
        ("PSG", "Clermont", "Ligue 1", {'tipo': 'ancla_local_extrema', 'prob_local': 0.79}),
        ("Bayern Munich", "Darmstadt", "Bundesliga", {'tipo': 'ancla_local_extrema', 'prob_local': 0.77}),
        ("Inter Milan", "Salernitana", "Serie A", {'tipo': 'ancla_local_extrema', 'prob_local': 0.75}),
        ("Liverpool", "Luton Town", "Premier League", {'tipo': 'ancla_local_extrema', 'prob_local': 0.74}),
        
        # ANCLAS VISITANTES EXTREMAS
        ("Burnley", "Arsenal", "Premier League", {'tipo': 'ancla_visitante_extrema', 'prob_visitante': 0.72}),
        ("Granada", "Barcelona", "La Liga", {'tipo': 'ancla_visitante_extrema', 'prob_visitante': 0.71}),
        
        # ANCLAS DE EMPATE MUY FUERTES
        ("Atl√©tico Madrid", "Real Betis", "La Liga", {'tipo': 'empate_fuerte_extremo', 'prob_empate': 0.44}),
        ("Juventus", "AC Milan", "Serie A", {'tipo': 'empate_fuerte_extremo', 'prob_empate': 0.43}),
        
        # DIVISORES EQUILIBRADOS
        ("Sevilla", "Valencia", "La Liga", {'tipo': 'divisor_equilibrado'}),
        ("Napoli", "Roma", "Serie A", {'tipo': 'divisor_equilibrado'}),
        ("Borussia Dortmund", "RB Leipzig", "Bundesliga", {'tipo': 'divisor_equilibrado'}),
        ("Manchester United", "Tottenham", "Premier League", {'tipo': 'divisor_equilibrado'})
    ]
    
    # Equipos para revancha (cl√°sicos con historia)
    equipos_revancha = [
        ("Boca Juniors", "River Plate", "Liga Argentina", {'tipo': 'clasico_equilibrado'}),
        ("Am√©rica", "Chivas", "Liga MX", {'tipo': 'empate_fuerte', 'prob_empate': 0.40}),
        ("Corinthians", "Palmeiras", "Brasileirao", {'tipo': 'clasico_equilibrado'}),
        ("Nacional", "Pe√±arol", "Liga Uruguaya", {'tipo': 'empate_fuerte', 'prob_empate': 0.38}),
        ("Colo Colo", "Universidad de Chile", "Liga Chilena", {'tipo': 'clasico_equilibrado'}),
        ("Millonarios", "Santa Fe", "Liga Colombiana", {'tipo': 'divisor_equilibrado'}),
        ("Sporting Cristal", "Universitario", "Liga Peruana", {'tipo': 'empate_fuerte', 'prob_empate': 0.37})
    ]
    
    def generar_probabilidades_extremas(config):
        """Genera probabilidades EXTREMAS que sobreviven calibraci√≥n"""
        tipo = config['tipo']
        
        if tipo == 'ancla_local_extrema':
            # Probabilidades ALT√çSIMAS para locales
            prob_local = config.get('prob_local', 0.75)
            prob_empate = np.random.uniform(0.06, 0.10)  # Empate muy bajo
            prob_visitante = 1.0 - prob_local - prob_empate
        
        elif tipo == 'ancla_visitante_extrema':
            # Probabilidades ALT√çSIMAS para visitantes
            prob_visitante = config.get('prob_visitante', 0.70)
            prob_empate = np.random.uniform(0.06, 0.10)  # Empate muy bajo
            prob_local = 1.0 - prob_empate - prob_visitante
        
        elif tipo == 'empate_fuerte_extremo':
            # Empates MUY altos
            prob_empate = config.get('prob_empate', 0.42)
            diff = 1.0 - prob_empate
            prob_local = np.random.uniform(0.25, diff - 0.25)
            prob_visitante = diff - prob_local
        
        elif tipo == 'clasico_equilibrado':
            # Cl√°sicos muy equilibrados
            prob_empate = np.random.uniform(0.32, 0.38)
            prob_local = np.random.uniform(0.30, 0.40)
            prob_visitante = 1.0 - prob_empate - prob_local
        
        else:  # divisor_equilibrado
            # Divisores con buena variabilidad
            prob_local = np.random.uniform(0.35, 0.50)
            prob_empate = np.random.uniform(0.25, 0.35)
            prob_visitante = 1.0 - prob_local - prob_empate
        
        # Normalizar para garantizar suma = 1.0
        total = prob_local + prob_empate + prob_visitante
        return prob_local/total, prob_empate/total, prob_visitante/total
    
    def crear_partidos_extremos(equipos_lista, es_revancha=False):
        """Crea partidos con datos extremos para garantizar Anclas"""
        partidos = []
        
        for i, (home, away, liga, config) in enumerate(equipos_lista):
            prob_local, prob_empate, prob_visitante = generar_probabilidades_extremas(config)
            
            # Factores contextuales M√çNIMOS para no afectar calibraci√≥n
            es_derbi = any(palabra in f"{home} {away}".lower() for palabra in ['cl√°sico', 'derbi', 'united'])
            
            partido = {
                'id': i,
                'home': home,
                'away': away,
                'liga': liga,
                'prob_local': prob_local,
                'prob_empate': prob_empate,
                'prob_visitante': prob_visitante,
                # FACTORES M√çNIMOS para preservar probabilidades extremas
                'forma_diferencia': np.random.normal(0, 0.02),  # Muy muy peque√±o
                'lesiones_impact': np.random.normal(0, 0.01),   # Casi nulo
                'es_final': False,  # No finales para evitar boost
                'es_derbi': es_derbi,
                'es_playoff': False,
                'fecha': '2025-06-26',
                'jornada': 1,
                'concurso_id': '2284',
                'tipo_original': config['tipo']  # Para debug
            }
            partidos.append(partido)
        
        return partidos
    
    partidos_regular = crear_partidos_extremos(equipos_regular, False)
    partidos_revancha = crear_partidos_extremos(equipos_revancha, True)
    
    # VERIFICACI√ìN EXTREMA: Contar Anclas potenciales
    anclas_potenciales = 0
    anclas_super_fuertes = 0
    
    for p in partidos_regular:
        max_prob = max(p['prob_local'], p['prob_empate'], p['prob_visitante'])
        if max_prob > 0.65:
            anclas_potenciales += 1
        if max_prob > 0.75:
            anclas_super_fuertes += 1
    
    logging.info(f"‚úÖ Datos generados: {anclas_super_fuertes} Anclas s√∫per fuertes, {anclas_potenciales} potenciales")
    
    return {
        'partidos_regular': partidos_regular,
        'partidos_revancha': partidos_revancha,
        'estadisticas': {
            'anclas_potenciales': anclas_potenciales,
            'anclas_super_fuertes': anclas_super_fuertes,
            'garantia_anclas': anclas_super_fuertes >= 8
        }
    }

# ===========================
# UTILIDADES DE EXPORTACI√ìN
# ===========================

def crear_reporte_completo(resultado_portafolio: Dict, validacion: Dict = None) -> str:
    """Crea reporte completo en texto"""
    
    timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    
    reporte = f"""
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë                            PROGOL DEFINITIVO v2.0                           ‚ïë
‚ïë                         REPORTE DE OPTIMIZACI√ìN                             ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

üìÖ FECHA: {timestamp}
üéØ CONCURSO: {resultado_portafolio['partidos_regular'][0]['concurso_id']}
‚ö° METODOLOG√çA: Core + Sat√©lites con Calibraci√≥n Bayesiana

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
üìä RESUMEN DEL PORTAFOLIO
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

‚Ä¢ Tipo: {resultado_portafolio['resumen']['tipo']}
‚Ä¢ Anclas detectadas: {resultado_portafolio['resumen']['anclas_detectadas']} (objetivo: ‚â•6)
‚Ä¢ Quinielas regulares: {resultado_portafolio['resumen']['quinielas_generadas']}
‚Ä¢ Empates promedio: {resultado_portafolio['resumen']['empates_promedio']:.1f}
"""
    
    if 'quinielas_revancha' in resultado_portafolio['resumen']:
        reporte += f"‚Ä¢ Quinielas revancha: {resultado_portafolio['resumen']['quinielas_revancha']}\n"
        reporte += f"‚Ä¢ Empates promedio revancha: {resultado_portafolio['resumen']['empates_promedio_revancha']:.1f}\n"
    
    # Arquitectura
    quinielas = resultado_portafolio['quinielas_regular']
    cores = len([q for q in quinielas if q['tipo'] == 'Core'])
    satelites = len([q for q in quinielas if q['tipo'] == 'Satelite'])
    
    reporte += f"""
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
üèóÔ∏è ARQUITECTURA
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

‚Ä¢ Quinielas Core: {cores}
‚Ä¢ Quinielas Sat√©lites: {satelites}
‚Ä¢ Pares anticorrelados: {satelites // 2}
‚Ä¢ Total quinielas: {len(quinielas)}
"""
    
    # Validaci√≥n
    if validacion:
        estado = "‚úÖ V√ÅLIDO" if validacion['es_valido'] else "‚ùå REQUIERE CORRECCIONES"
        reporte += f"""
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
‚úÖ VALIDACI√ìN DEL PORTAFOLIO
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

üîç ESTADO GENERAL: {estado}
üìã REGLAS CUMPLIDAS: {validacion['reglas_cumplidas']}

DETALLE POR REGLA:
"""
        
        reglas_desc = {
            'empates_individuales': 'Empates 4-6 por quiniela',
            'distribucion_global': 'Distribuci√≥n global hist√≥rica',
            'concentracion_maxima': 'Concentraci√≥n ‚â§70% general, ‚â§60% inicial',
            'arquitectura': 'Arquitectura Core + Sat√©lites',
            'correlacion_satelites': 'Correlaci√≥n entre sat√©lites',
            'equilibrio_distribucional': 'Equilibrio distribucional'
        }
        
        for regla, cumple in validacion['reglas'].items():
            estado_regla = "‚úÖ" if cumple else "‚ùå"
            desc = reglas_desc.get(regla, regla)
            reporte += f"‚Ä¢ {estado_regla} {desc}\n"
        
        # M√©tricas
        metricas = validacion['metricas']
        reporte += f"""
üìä M√âTRICAS DETALLADAS:
‚Ä¢ Distribuci√≥n global: L={metricas['distribucion_global']['L_porc']}, E={metricas['distribucion_global']['E_porc']}, V={metricas['distribucion_global']['V_porc']}
‚Ä¢ Empates por quiniela: {metricas['empates_estadisticas']['minimo']}-{metricas['empates_estadisticas']['maximo']} (promedio: {metricas['empates_estadisticas']['promedio']:.1f})
‚Ä¢ Quinielas fuera de rango: {metricas['empates_estadisticas']['fuera_rango']}
‚Ä¢ Probabilidad ‚â•11 promedio: {metricas['probabilidad_11_plus']['promedio']:.1%}
"""
        
        # Diagn√≥stico
        reporte += f"""
üîç DIAGN√ìSTICO:
{validacion['diagnostico']}
"""
        
        # Recomendaciones
        if validacion['recomendaciones']:
            reporte += f"\nüí° RECOMENDACIONES:\n"
            for rec in validacion['recomendaciones']:
                reporte += f"‚Ä¢ {rec}\n"
    
    # Footer
    reporte += f"""
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
üìÑ INFORMACI√ìN T√âCNICA
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

‚Ä¢ Aplicaci√≥n: {PROGOL_CONFIG['APP_NAME']} v{PROGOL_CONFIG['APP_VERSION']}
‚Ä¢ Metodolog√≠a: {PROGOL_CONFIG['METODOLOGIA']}
‚Ä¢ Umbrales Ancla: ‚â•{PROGOL_CONFIG['UMBRALES_CLASIFICACION']['ancla_prob_min']:.0%} + diferencia ‚â•{PROGOL_CONFIG['UMBRALES_CLASIFICACION']['ancla_diferencia_min']:.0%}
‚Ä¢ Calibraci√≥n: k1={PROGOL_CONFIG['CALIBRACION_COEFICIENTES']['k1_forma']}, k2={PROGOL_CONFIG['CALIBRACION_COEFICIENTES']['k2_lesiones']}, k3={PROGOL_CONFIG['CALIBRACION_COEFICIENTES']['k3_contexto']}

üèÜ ¬°Listo para competir por el premio mayor!
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
"""
    
    return reporte

def exportar_csv_quinielas(quinielas: List[Dict], tipo: str = "Regular") -> str:
    """Exporta quinielas a formato CSV"""
    data = []
    
    for q in quinielas:
        row = {
            'ID': q['id'],
            'Tipo': q['tipo'],
            'Empates': q['empates'],
            'Prob_11_Plus': f"{q.get('prob_11_plus', 0):.1%}",
            'Valida': "‚úÖ" if q.get('valida', True) else "‚ùå"
        }
        
        # Agregar resultados por partido
        for i, resultado in enumerate(q['resultados']):
            row[f'P{i+1:02d}'] = resultado
        
        # Agregar distribuci√≥n
        row['Total_L'] = q['distribucion']['L']
        row['Total_E'] = q['distribucion']['E']
        row['Total_V'] = q['distribucion']['V']
        
        data.append(row)
    
    df = pd.DataFrame(data)
    return df.to_csv(index=False)

def exportar_json_completo(resultado_portafolio: Dict, validacion: Dict = None) -> str:
    """Exporta resultado completo a JSON"""
    data = {
        'metadata': {
            'aplicacion': PROGOL_CONFIG['APP_NAME'],
            'version': PROGOL_CONFIG['APP_VERSION'],
            'metodologia': PROGOL_CONFIG['METODOLOGIA'],
            'generado': datetime.now().isoformat(),
            'configuracion': PROGOL_CONFIG
        },
        'resultado_portafolio': resultado_portafolio
    }
    
    if validacion:
        data['validacion'] = validacion
    
    return json.dumps(data, indent=2, ensure_ascii=False, default=str)

# ===========================
# INTERFAZ PRINCIPAL DE STREAMLIT
# ===========================

def main():
    """Aplicaci√≥n principal con interfaz completa"""
    
    # Header principal
    st.title("üèÜ PROGOL DEFINITIVO")
    st.markdown("### üéØ La aplicaci√≥n que S√ç funciona - Metodolog√≠a Real v2.0")
    
    # Informaci√≥n de estado en header
    mostrar_info_estado()
    
    # Sidebar con configuraci√≥n
    configurar_sidebar()
    
    # Tabs principales del flujo
    tab1, tab2, tab3, tab4, tab5 = st.tabs([
        "üìä DATOS", 
        "üîç CLASIFICACI√ìN", 
        "üéØ GENERACI√ìN", 
        "‚úÖ VALIDACI√ìN",
        "üìÑ EXPORTAR"
    ])
    
    with tab1:
        seccion_datos()
    
    with tab2:
        seccion_clasificacion()
    
    with tab3:
        seccion_generacion()
    
    with tab4:
        seccion_validacion()
    
    with tab5:
        seccion_exportar()

def mostrar_info_estado():
    """Muestra el estado actual del flujo en tiempo real"""
    
    # Crear contenedor para el estado
    estado_container = st.container()
    
    with estado_container:
        col1, col2, col3, col4, col5, col6 = st.columns(6)
        
        # Estado de cada paso
        datos_ok = 'datos_cargados' in st.session_state
        clasificacion_ok = 'partidos_clasificados' in st.session_state
        anclas_ok = clasificacion_ok and len([p for p in st.session_state.get('partidos_clasificados', []) if p.get('clasificacion') == 'Ancla']) >= 6
        generacion_ok = 'portafolio_generado' in st.session_state
        validacion_ok = 'validacion_completa' in st.session_state and st.session_state.validacion_completa.get('es_valido', False)
        
        with col1:
            estado = "‚úÖ" if datos_ok else "‚è≥"
            st.metric("üìä Datos", estado)
        
        with col2:
            estado = "‚úÖ" if clasificacion_ok else "‚è≥"
            st.metric("üîç Clasificaci√≥n", estado)
        
        with col3:
            if clasificacion_ok:
                num_anclas = len([p for p in st.session_state.get('partidos_clasificados', []) if p.get('clasificacion') == 'Ancla'])
                estado = "‚úÖ" if anclas_ok else f"‚ùå({num_anclas})"
                st.metric("‚öì Anclas", estado)
            else:
                st.metric("‚öì Anclas", "‚è≥")
        
        with col4:
            estado = "‚úÖ" if generacion_ok else "‚è≥"
            st.metric("üéØ Generaci√≥n", estado)
        
        with col5:
            if 'validacion_completa' in st.session_state:
                validacion = st.session_state.validacion_completa
                if validacion.get('es_valido'):
                    estado = "‚úÖ"
                else:
                    cumplidas = validacion.get('reglas_cumplidas', '0/6')
                    estado = f"‚ö†Ô∏è{cumplidas}"
                st.metric("‚úÖ Validaci√≥n", estado)
            else:
                st.metric("‚úÖ Validaci√≥n", "‚è≥")
        
        with col6:
            progreso = sum([datos_ok, clasificacion_ok, anclas_ok, generacion_ok, validacion_ok])
            color = "normal"
            if progreso >= 4:
                color = "inverse"
            st.metric("üìà Progreso", f"{progreso}/5", delta_color=color)

def configurar_sidebar():
    """Configura el sidebar con controles principales"""
    with st.sidebar:
        st.header("‚öôÔ∏è CONFIGURACI√ìN")
        
        # Informaci√≥n de la app
        st.info(f"""
        **{PROGOL_CONFIG['APP_NAME']}** v{PROGOL_CONFIG['APP_VERSION']}
        
        üéØ {PROGOL_CONFIG['METODOLOGIA']}
        
        **Caracter√≠sticas:**
        ‚úÖ Umbrales realistas para Anclas  
        ‚úÖ Calibraci√≥n bayesiana ligera  
        ‚úÖ Arquitectura Core + Sat√©lites  
        ‚úÖ Correcci√≥n autom√°tica  
        ‚úÖ Regular + Revancha simult√°neo
        """)
        
        # Bot√≥n de reset global
        st.markdown("---")
        if st.button("üîÑ REINICIAR TODO", type="secondary"):
            # Limpiar todo el session_state
            for key in list(st.session_state.keys()):
                del st.session_state[key]
            st.success("‚úÖ Aplicaci√≥n reiniciada")
            st.rerun()
        
        # Configuraci√≥n de quinielas
        st.subheader("üìä Par√°metros")
        
        num_quinielas_regular = st.slider(
            "Quinielas Regular", 
            min_value=20, 
            max_value=40, 
            value=30,
            help="N√∫mero de quinielas para concurso regular (14 partidos)"
        )
        
        num_quinielas_revancha = st.slider(
            "Quinielas Revancha", 
            min_value=10, 
            max_value=25, 
            value=15,
            help="N√∫mero de quinielas para concurso revancha (7 partidos)"
        )
        
        # Guardar configuraci√≥n
        st.session_state.config = {
            'num_quinielas_regular': num_quinielas_regular,
            'num_quinielas_revancha': num_quinielas_revancha
        }
        
        # Configuraci√≥n avanzada
        with st.expander("‚öôÔ∏è Configuraci√≥n Avanzada"):
            st.markdown(f"""
            **Umbrales de Clasificaci√≥n:**
            - Ancla: ‚â•{PROGOL_CONFIG['UMBRALES_CLASIFICACION']['ancla_prob_min']:.0%} + diferencia ‚â•{PROGOL_CONFIG['UMBRALES_CLASIFICACION']['ancla_diferencia_min']:.0%}
            - Empate: ‚â•{PROGOL_CONFIG['UMBRALES_CLASIFICACION']['empate_min']:.0%}
            
            **Calibraci√≥n Bayesiana:**
            - Forma: {PROGOL_CONFIG['CALIBRACION_COEFICIENTES']['k1_forma']}
            - Lesiones: {PROGOL_CONFIG['CALIBRACION_COEFICIENTES']['k2_lesiones']}
            - Contexto: {PROGOL_CONFIG['CALIBRACION_COEFICIENTES']['k3_contexto']}
            
            **Arquitectura:**
            - Cores: {PROGOL_CONFIG['ARQUITECTURA']['num_core']}
            - Empates: {PROGOL_CONFIG['EMPATES_MIN']}-{PROGOL_CONFIG['EMPATES_MAX']}
            """)
        
        # Estad√≠sticas hist√≥ricas
        with st.expander("üìà Distribuci√≥n Hist√≥rica"):
            dist = PROGOL_CONFIG['DISTRIBUCION_HISTORICA']
            
            col1, col2, col3 = st.columns(3)
            with col1:
                st.metric("Locales", f"{dist['L']:.0%}")
            with col2:
                st.metric("Empates", f"{dist['E']:.0%}")
            with col3:
                st.metric("Visitantes", f"{dist['V']:.0%}")
            
            st.caption(f"üìä Promedio hist√≥rico: {PROGOL_CONFIG['EMPATES_PROMEDIO']} empates/quiniela")

def seccion_datos():
    """Secci√≥n de carga y verificaci√≥n de datos"""
    st.header("üìä CARGA DE DATOS")
    
    col1, col2 = st.columns([2, 1])
    
    with col1:
        st.subheader("‚öΩ Partidos del Concurso")
        
        # Bot√≥n principal para generar datos
        if st.button("üé≤ GENERAR DATOS DE EJEMPLO", type="primary", help="Genera datos con Anclas garantizadas"):
            with st.spinner("Generando datos extremos con Anclas garantizadas..."):
                datos_ejemplo = generar_datos_ejemplo_extremos()
                
                # Guardar en session state
                st.session_state.partidos_regular = datos_ejemplo['partidos_regular']
                st.session_state.partidos_revancha = datos_ejemplo['partidos_revancha']
                st.session_state.datos_cargados = True
                st.session_state.estadisticas_datos = datos_ejemplo['estadisticas']
                
                st.success("‚úÖ Datos generados con Anclas extremas")
                st.rerun()
    
    with col2:
        # Estado de los datos
        if 'datos_cargados' in st.session_state:
            st.success("‚úÖ Datos cargados")
            
            # Mostrar estad√≠sticas de datos
            if 'estadisticas_datos' in st.session_state:
                stats = st.session_state.estadisticas_datos
                
                st.metric("Anclas S√∫per Fuertes", stats['anclas_super_fuertes'])
                st.metric("Anclas Potenciales", stats['anclas_potenciales'])
                
                if stats['garantia_anclas']:
                    st.success("üéØ Anclas garantizadas")
                else:
                    st.warning("‚ö†Ô∏è Pocas Anclas")
        else:
            st.info("‚è≥ Esperando datos")
    
    # Mostrar datos cargados
    if 'partidos_regular' in st.session_state:
        
        # Tabs para regular y revancha
        tab_reg, tab_rev = st.tabs(["‚öΩ Partidos Regulares (14)", "üèÜ Partidos Revancha (7)"])
        
        with tab_reg:
            partidos_reg = st.session_state.partidos_regular
            st.success(f"‚úÖ {len(partidos_reg)} partidos regulares cargados")
            
            # Preview de datos
            preview_data = []
            for i, p in enumerate(partidos_reg):
                max_prob = max(p['prob_local'], p['prob_empate'], p['prob_visitante'])
                preview_data.append({
                    'P': i+1,
                    'Local': p['home'][:20],
                    'Visitante': p['away'][:20],
                    'Liga': p['liga'][:15],
                    'Prob_Max': f"{max_prob:.2f}",
                    'Tipo': p.get('tipo_original', 'N/A')[:15]
                })
            
            df_preview = pd.DataFrame(preview_data)
            st.dataframe(df_preview, use_container_width=True)
        
        with tab_rev:
            if 'partidos_revancha' in st.session_state:
                partidos_rev = st.session_state.partidos_revancha
                st.success(f"‚úÖ {len(partidos_rev)} partidos revancha cargados")
                
                # Preview de revancha
                preview_rev = []
                for i, p in enumerate(partidos_rev):
                    max_prob = max(p['prob_local'], p['prob_empate'], p['prob_visitante'])
                    preview_rev.append({
                        'P': i+1,
                        'Local': p['home'][:20],
                        'Visitante': p['away'][:20],
                        'Liga': p['liga'][:15],
                        'Prob_Max': f"{max_prob:.2f}",
                        'Tipo': p.get('tipo_original', 'N/A')[:15]
                    })
                
                df_rev = pd.DataFrame(preview_rev)
                st.dataframe(df_rev, use_container_width=True)
            else:
                st.info("‚è≥ Se cargar√°n autom√°ticamente con los datos regulares")

def seccion_clasificacion():
    """Secci√≥n de clasificaci√≥n de partidos"""
    st.header("üîç CLASIFICACI√ìN DE PARTIDOS")
    
    if 'partidos_regular' not in st.session_state:
        st.warning("‚ö†Ô∏è Primero carga los datos en la pesta√±a **DATOS**")
        return
    
    # Informaci√≥n de umbrales
    col1, col2 = st.columns([2, 1])
    
    with col1:
        if st.button("‚ñ∂Ô∏è CLASIFICAR PARTIDOS", type="primary"):
            with st.spinner("Aplicando calibraci√≥n bayesiana y clasificando..."):
                clasificador = ClasificadorMejorado()
                
                # Clasificar partidos regulares
                partidos_reg_clasificados = clasificador.clasificar_partidos(st.session_state.partidos_regular)
                st.session_state.partidos_clasificados = partidos_reg_clasificados
                
                # Clasificar revancha si existe
                if 'partidos_revancha' in st.session_state:
                    partidos_rev_clasificados = clasificador.clasificar_partidos(st.session_state.partidos_revancha)
                    st.session_state.partidos_revancha_clasificados = partidos_rev_clasificados
                
                st.success("‚úÖ Clasificaci√≥n completada con umbrales realistas")
                st.rerun()
    
    with col2:
        # Mostrar umbrales actuales
        st.info(f"""
        **Umbrales REALISTAS:**
        - Ancla: ‚â•50% + diff ‚â•8%
        - Empate: ‚â•35%
        - Divisor: 35-50%
        """)
    
    # Mostrar resultados de clasificaci√≥n
    if 'partidos_clasificados' in st.session_state:
        partidos = st.session_state.partidos_clasificados
        
        # Estad√≠sticas principales
        st.subheader("üìä Estad√≠sticas de Clasificaci√≥n")
        
        clasificaciones = {}
        for p in partidos:
            clase = p['clasificacion']
            clasificaciones[clase] = clasificaciones.get(clase, 0) + 1
        
        col1, col2, col3, col4 = st.columns(4)
        
        with col1:
            anclas = clasificaciones.get('Ancla', 0)
            estado = "‚úÖ" if anclas >= 6 else "‚ùå"
            st.metric(f"‚öì Anclas {estado}", anclas, help="M√≠nimo 6 necesarias")
        
        with col2:
            divisores = clasificaciones.get('Divisor', 0)
            st.metric("üîÑ Divisores", divisores, help="Partidos equilibrados")
        
        with col3:
            empates = clasificaciones.get('TendenciaEmpate', 0)
            st.metric("‚öñÔ∏è Tend. Empate", empates, help="Alta probabilidad de empate")
        
        with col4:
            neutros = clasificaciones.get('Neutro', 0)
            st.metric("‚ö™ Neutros", neutros, help="Sin clasificaci√≥n especial")
        
        # Verificar que hay suficientes Anclas
        if anclas < 6:
            st.error(f"""
            ‚ùå **PROBLEMA CR√çTICO**: Solo {anclas} Anclas detectadas
            
            **Se necesitan al menos 6 Anclas para un portafolio v√°lido.**
            
            üí° **Soluci√≥n**: Regresa a **DATOS** y genera nuevos datos de ejemplo.
            Los datos actuales tienen probabilidades demasiado bajas.
            """)
            return
        else:
            st.success(f"üéØ {anclas} Anclas detectadas - Suficientes para continuar")
        
        # Tabla detallada con colores
        st.subheader("üìã Detalle de Partidos Clasificados")
        
        # Preparar datos para la tabla
        tabla_data = []
        for i, p in enumerate(partidos):
            
            # Color seg√∫n clasificaci√≥n
            if p['clasificacion'] == 'Ancla':
                emoji = "‚öì"
                color = "üü¢"
            elif p['clasificacion'] == 'TendenciaEmpate':
                emoji = "‚öñÔ∏è"
                color = "üü°"
            elif p['clasificacion'] == 'Divisor':
                emoji = "üîÑ"
                color = "üîµ"
            else:
                emoji = "‚ö™"
                color = "‚ö´"
            
            max_prob = max(p['prob_local'], p['prob_empate'], p['prob_visitante'])
            
            tabla_data.append({
                'P': f"{i+1:02d}",
                'Estado': f"{color} {emoji}",
                'Local': p['home'][:18],
                'Visitante': p['away'][:18],
                'Liga': p['liga'][:12],
                'Prob_L': f"{p['prob_local']:.3f}",
                'Prob_E': f"{p['prob_empate']:.3f}",
                'Prob_V': f"{p['prob_visitante']:.3f}",
                'Max': f"{max_prob:.3f}",
                'Clasificaci√≥n': p['clasificacion'],
                'Calibrado': "‚úÖ" if p.get('calibrado') else "‚ùå"
            })
        
        df_tabla = pd.DataFrame(tabla_data)
        st.dataframe(df_tabla, use_container_width=True)
        
        # Informaci√≥n adicional sobre calibraci√≥n
        with st.expander("üîç Informaci√≥n de Calibraci√≥n"):
            st.markdown("""
            **Calibraci√≥n Bayesiana Aplicada:**
            - Factor forma reciente: muy bajo (0.05)
            - Factor lesiones: muy bajo (0.03) 
            - Factor contexto: moderado (0.08)
            
            **Objetivo**: Preservar probabilidades altas para mantener Anclas v√°lidas.
            """)

def seccion_generacion():
    """Secci√≥n de generaci√≥n de portafolio"""
    st.header("üéØ GENERACI√ìN DE PORTAFOLIO")
    
    if 'partidos_clasificados' not in st.session_state:
        st.warning("‚ö†Ô∏è Primero completa la **CLASIFICACI√ìN**")
        return
    
    # Verificar Anclas
    partidos = st.session_state.partidos_clasificados
    anclas = [p for p in partidos if p['clasificacion'] == 'Ancla']
    
    if len(anclas) < 6:
        st.error(f"‚ùå Solo {len(anclas)} Anclas detectadas. Necesitas al menos 6.")
        st.info("üí° Regresa a **DATOS** y genera nuevos datos de ejemplo")
        return
    
    # Informaci√≥n previa a generaci√≥n
    col1, col2 = st.columns([2, 1])
    
    with col1:
        st.success(f"‚úÖ {len(anclas)} Anclas detectadas - Listo para generar")
        
        # Configuraci√≥n de generaci√≥n
        config = st.session_state.get('config', {})
        num_reg = config.get('num_quinielas_regular', 30)
        num_rev = config.get('num_quinielas_revancha', 15)
        
        st.info(f"""
        **Configuraci√≥n de Generaci√≥n:**
        - Quinielas regulares: {num_reg}
        - Quinielas revancha: {num_rev}
        - Arquitectura: 4 Core + {num_reg-4} Sat√©lites
        """)
        
        # Bot√≥n de generaci√≥n
        if st.button("‚ñ∂Ô∏è GENERAR PORTAFOLIO COMPLETO", type="primary"):
            with st.spinner("Generando portafolio optimizado con arquitectura Core + Sat√©lites..."):
                
                generador = GeneradorPortafolio()
                
                # Obtener datos
                partidos_regular = st.session_state.partidos_clasificados
                partidos_revancha = st.session_state.get('partidos_revancha_clasificados', [])
                
                # Verificar si tenemos suficientes partidos de revancha
                partidos_rev_validos = partidos_revancha if len(partidos_revancha) >= 7 else None
                
                # Generar portafolio
                resultado = generador.generar_portafolio_completo(
                    partidos_regular,
                    partidos_rev_validos,
                    num_reg,
                    num_rev
                )
                
                if resultado:
                    st.session_state.portafolio_generado = resultado
                    st.success("‚úÖ Portafolio generado exitosamente")
                    st.balloons()
                    st.rerun()
                else:
                    st.error("‚ùå Error generando portafolio")
    
    with col2:
        # Lista de Anclas detectadas
        st.subheader("‚öì Anclas Detectadas")
        for i, ancla in enumerate(anclas):
            max_prob = max(ancla['prob_local'], ancla['prob_empate'], ancla['prob_visitante'])
            resultado_ancla = ['L', 'E', 'V'][np.argmax([ancla['prob_local'], ancla['prob_empate'], ancla['prob_visitante']])]
            
            st.write(f"**P{[j for j, p in enumerate(partidos) if p['id'] == ancla['id']][0]+1:02d}**: {ancla['home'][:12]} vs {ancla['away'][:12]}")
            st.write(f"   ‚Üí {resultado_ancla} ({max_prob:.1%})")
    
    # Mostrar resultados de generaci√≥n
    if 'portafolio_generado' in st.session_state:
        resultado = st.session_state.portafolio_generado
        
        # Resumen del portafolio
        st.subheader("üìä Resumen del Portafolio Generado")
        
        col1, col2, col3, col4 = st.columns(4)
        
        with col1:
            st.metric("‚öì Anclas Usadas", resultado['resumen']['anclas_detectadas'])
        
        with col2:
            st.metric("‚öΩ Quinielas Regular", resultado['resumen']['quinielas_generadas'])
        
        with col3:
            if 'quinielas_revancha' in resultado['resumen']:
                st.metric("üèÜ Quinielas Revancha", resultado['resumen']['quinielas_revancha'])
            else:
                st.metric("üèÜ Quinielas Revancha", "No generadas")
        
        with col4:
            st.metric("üìä Empates Promedio", f"{resultado['resumen']['empates_promedio']:.1f}")
        
        # An√°lisis de arquitectura
        quinielas_reg = resultado['quinielas_regular']
        cores = [q for q in quinielas_reg if q['tipo'] == 'Core']
        satelites = [q for q in quinielas_reg if q['tipo'] == 'Satelite']
        
        st.subheader("üèóÔ∏è Arquitectura Generada")
        
        col1, col2, col3 = st.columns(3)
        
        with col1:
            st.metric("üéØ Cores", len(cores), help="Quinielas base estables")
        
        with col2:
            st.metric("üõ∞Ô∏è Sat√©lites", len(satelites), help="Quinielas con variaci√≥n controlada")
        
        with col3:
            pares = len(satelites) // 2
            st.metric("üîó Pares Anticorrelados", pares, help="Pares con correlaci√≥n negativa")
        
        # Preview de quinielas (primeras 10)
        st.subheader("üìã Preview de Quinielas (Primeras 10)")
        
        preview_quinielas = quinielas_reg[:10]
        
        tabla_preview = []
        for q in preview_quinielas:
            row = {
                'ID': q['id'],
                'Tipo': q['tipo'],
                'Empates': q['empates'],
                'Prob‚â•11': f"{q.get('prob_11_plus', 0):.1%}",
                'Estado': "‚úÖ" if q.get('valida', True) else "‚ùå"
            }
            
            # Agregar primeros 8 partidos para preview
            for i in range(8):
                row[f'P{i+1}'] = q['resultados'][i]
            
            row['...'] = '...'
            
            tabla_preview.append(row)
        
        df_preview = pd.DataFrame(tabla_preview)
        st.dataframe(df_preview, use_container_width=True)
        
        # Distribuci√≥n global r√°pida
        total_L = sum(q['distribucion']['L'] for q in quinielas_reg)
        total_E = sum(q['distribucion']['E'] for q in quinielas_reg)
        total_V = sum(q['distribucion']['V'] for q in quinielas_reg)
        total_partidos = len(quinielas_reg) * 14
        
        st.subheader("üåç Distribuci√≥n Global Preliminar")
        
        col1, col2, col3 = st.columns(3)
        
        with col1:
            porc_L = total_L / total_partidos
            estado_L = "‚úÖ" if 0.35 <= porc_L <= 0.41 else "‚ö†Ô∏è"
            st.metric(f"Locales {estado_L}", f"{porc_L:.1%}", help="Objetivo: 35-41%")
        
        with col2:
            porc_E = total_E / total_partidos
            estado_E = "‚úÖ" if 0.25 <= porc_E <= 0.33 else "‚ö†Ô∏è"
            st.metric(f"Empates {estado_E}", f"{porc_E:.1%}", help="Objetivo: 25-33%")
        
        with col3:
            porc_V = total_V / total_partidos
            estado_V = "‚úÖ" if 0.30 <= porc_V <= 0.36 else "‚ö†Ô∏è"
            st.metric(f"Visitantes {estado_V}", f"{porc_V:.1%}", help="Objetivo: 30-36%")
        
        # Informaci√≥n adicional
        with st.expander("‚ÑπÔ∏è Informaci√≥n T√©cnica de Generaci√≥n"):
            st.markdown(f"""
            **Proceso de Generaci√≥n Completado:**
            
            1. ‚úÖ **Core Generation**: 4 quinielas base estables
            2. ‚úÖ **Satellite Generation**: {len(satelites)} quinielas con variaci√≥n controlada
            3. ‚úÖ **Anticorrelation**: {pares} pares con correlaci√≥n negativa
            4. ‚úÖ **Auto-correction**: Correcci√≥n autom√°tica de empates y concentraci√≥n
            5. ‚úÖ **Validation**: Verificaci√≥n de reglas b√°sicas
            
            **Metodolog√≠a Aplicada:**
            - Anclas: Siempre resultado m√°s probable (nunca cambian)
            - Divisores: Probabil√≠stico con variaci√≥n entre sat√©lites
            - TendenciaEmpate: 75% probabilidad de empate
            - Empates: Ajustados autom√°ticamente al rango 4-6
            """)

def seccion_validacion():
    """Secci√≥n de validaci√≥n completa del portafolio"""
    st.header("‚úÖ VALIDACI√ìN DEL PORTAFOLIO")
    
    if 'portafolio_generado' not in st.session_state:
        st.warning("‚ö†Ô∏è Primero completa la **GENERACI√ìN**")
        return
    
    resultado = st.session_state.portafolio_generado
    
    # Bot√≥n de validaci√≥n
    col1, col2 = st.columns([2, 1])
    
    with col1:
        if st.button("‚ñ∂Ô∏è VALIDAR PORTAFOLIO COMPLETO", type="primary"):
            with st.spinner("Ejecutando validaci√≥n completa seg√∫n las 6 reglas..."):
                
                validador = ValidadorCompleto()
                
                # Validar quinielas regulares
                quinielas_regular = resultado['quinielas_regular']
                validacion = validador.validar_portafolio(quinielas_regular, "Regular")
                
                st.session_state.validacion_completa = validacion
                
                # Si hay revancha, validar tambi√©n
                if 'quinielas_revancha' in resultado:
                    quinielas_revancha = resultado['quinielas_revancha']
                    validacion_revancha = validador.validar_portafolio(quinielas_revancha, "Revancha")
                    st.session_state.validacion_revancha = validacion_revancha
                
                st.success("‚úÖ Validaci√≥n completada")
                st.rerun()
    
    with col2:
        st.info("""
        **6 Reglas Validadas:**
        1. Empates 4-6 por quiniela
        2. Distribuci√≥n global hist√≥rica
        3. Concentraci√≥n ‚â§70%/‚â§60%
        4. Arquitectura Core + Sat√©lites
        5. Correlaci√≥n entre sat√©lites
        6. Equilibrio distribucional
        """)
    
    # Mostrar resultados de validaci√≥n
    if 'validacion_completa' in st.session_state:
        validacion = st.session_state.validacion_completa
        
        # Estado general prominente
        if validacion['es_valido']:
            st.success("üéâ **PORTAFOLIO COMPLETAMENTE V√ÅLIDO**")
            st.balloons()
        else:
            reglas_cumplidas = validacion['reglas_cumplidas']
            st.warning(f"‚ö†Ô∏è **PORTAFOLIO REQUIERE CORRECCIONES** ({reglas_cumplidas})")
        
        # Detalle por regla con iconos
        st.subheader("üìã Detalle por Regla")
        
        reglas = validacion['reglas']
        descripciones = {
            'empates_individuales': ('üéØ', 'Empates 4-6 por quiniela'),
            'distribucion_global': ('üåç', 'Distribuci√≥n global en rangos hist√≥ricos'),
            'concentracion_maxima': ('üìä', 'Concentraci√≥n ‚â§70% general, ‚â§60% inicial'),
            'arquitectura': ('üèóÔ∏è', 'Arquitectura Core + Sat√©lites'),
            'correlacion_satelites': ('üîó', 'Correlaci√≥n entre sat√©lites'),
            'equilibrio_distribucional': ('‚öñÔ∏è', 'Equilibrio distribucional')
        }
        
        # Mostrar reglas en dos columnas
        col1, col2 = st.columns(2)
        
        reglas_items = list(reglas.items())
        mitad = len(reglas_items) // 2
        
        with col1:
            for regla, cumple in reglas_items[:mitad]:
                emoji, descripcion = descripciones.get(regla, ('üîç', regla))
                estado = "‚úÖ CUMPLE" if cumple else "‚ùå FALLA"
                color = "normal" if cumple else "inverse"
                st.write(f"{emoji} **{descripcion}**: {estado}")
        
        with col2:
            for regla, cumple in reglas_items[mitad:]:
                emoji, descripcion = descripciones.get(regla, ('üîç', regla))
                estado = "‚úÖ CUMPLE" if cumple else "‚ùå FALLA"
                color = "normal" if cumple else "inverse"
                st.write(f"{emoji} **{descripcion}**: {estado}")
        
        # Diagn√≥stico detallado
        st.subheader("üîç Diagn√≥stico Detallado")
        
        diagnostico_lines = validacion['diagnostico'].split('\n')
        for line in diagnostico_lines:
            if line.strip():
                if line.startswith('‚ùå'):
                    st.error(line)
                elif line.startswith('‚úÖ'):
                    st.success(line)
                elif line.startswith('üéâ'):
                    st.success(line)
                else:
                    st.info(line)
        
        # M√©tricas completas
        st.subheader("üìä M√©tricas Completas del Portafolio")
        
        metricas = validacion['metricas']
        
        # M√©tricas principales
        col1, col2, col3, col4 = st.columns(4)
        
        with col1:
            st.metric("Total Quinielas", metricas['total_quinielas'])
        
        with col2:
            st.metric("Empates Promedio", f"{metricas['empates_estadisticas']['promedio']:.1f}")
        
        with col3:
            st.metric("Cores", metricas['arquitectura']['cores'])
        
        with col4:
            st.metric("Sat√©lites", metricas['arquitectura']['satelites'])
        
        # Distribuci√≥n global detallada
        st.subheader("üåç Distribuci√≥n Global Detallada")
        
        dist = metricas['distribucion_global']
        rangos = PROGOL_CONFIG['RANGOS_HISTORICOS']
        
        col1, col2, col3 = st.columns(3)
        
        with col1:
            porc_L = float(dist['L_porc'].strip('%')) / 100
            estado_L = "‚úÖ" if rangos['L'][0] <= porc_L <= rangos['L'][1] else "‚ùå"
            st.metric(f"Locales {estado_L}", dist['L_porc'], 
                     help=f"Objetivo: {rangos['L'][0]:.0%}-{rangos['L'][1]:.0%}")
        
        with col2:
            porc_E = float(dist['E_porc'].strip('%')) / 100
            estado_E = "‚úÖ" if rangos['E'][0] <= porc_E <= rangos['E'][1] else "‚ùå"
            st.metric(f"Empates {estado_E}", dist['E_porc'], 
                     help=f"Objetivo: {rangos['E'][0]:.0%}-{rangos['E'][1]:.0%}")
        
        with col3:
            porc_V = float(dist['V_porc'].strip('%')) / 100
            estado_V = "‚úÖ" if rangos['V'][0] <= porc_V <= rangos['V'][1] else "‚ùå"
            st.metric(f"Visitantes {estado_V}", dist['V_porc'], 
                     help=f"Objetivo: {rangos['V'][0]:.0%}-{rangos['V'][1]:.0%}")
        
        # Estad√≠sticas de empates
        st.subheader("üéØ Estad√≠sticas de Empates")
        
        empates_stats = metricas['empates_estadisticas']
        
        col1, col2, col3, col4 = st.columns(4)
        
        with col1:
            st.metric("M√≠nimo", empates_stats['minimo'])
        
        with col2:
            st.metric("M√°ximo", empates_stats['maximo'])
        
        with col3:
            st.metric("Promedio", f"{empates_stats['promedio']:.1f}")
        
        with col4:
            fuera_rango = empates_stats['fuera_rango']
            estado_rango = "‚úÖ" if fuera_rango == 0 else "‚ùå"
            st.metric(f"Fuera Rango {estado_rango}", fuera_rango)
        
        # Probabilidad de premio
        st.subheader("üí∞ Estimaci√≥n de Probabilidad de Premio")
        
        prob_stats = metricas['probabilidad_11_plus']
        
        col1, col2 = st.columns(2)
        
        with col1:
            st.metric("Prob ‚â•11 Promedio", f"{prob_stats['promedio']:.1%}")
        
        with col2:
            st.metric("Prob ‚â•11 M√°xima", f"{prob_stats['maximo']:.1%}")
        
        # Recomendaciones
        if validacion['recomendaciones']:
            st.subheader("üí° Recomendaciones")
            
            for rec in validacion['recomendaciones']:
                if rec.startswith('üéâ'):
                    st.success(rec)
                elif rec.startswith('üîß') or rec.startswith('‚öñÔ∏è') or rec.startswith('üìä'):
                    st.warning(rec)
                else:
                    st.info(rec)
        
        # Validaci√≥n de revancha si existe
        if 'validacion_revancha' in st.session_state:
            st.subheader("üèÜ Validaci√≥n Revancha")
            
            val_rev = st.session_state.validacion_revancha
            
            if val_rev['es_valido']:
                st.success(f"‚úÖ Revancha v√°lida ({val_rev['reglas_cumplidas']})")
            else:
                st.warning(f"‚ö†Ô∏è Revancha requiere correcciones ({val_rev['reglas_cumplidas']})")

def seccion_exportar():
    """Secci√≥n de exportaci√≥n completa"""
    st.header("üìÑ EXPORTAR RESULTADOS")
    
    if 'portafolio_generado' not in st.session_state:
        st.warning("‚ö†Ô∏è Primero completa la **GENERACI√ìN**")
        return
    
    resultado = st.session_state.portafolio_generado
    validacion = st.session_state.get('validacion_completa')
    
    # Advertencia si no est√° validado
    if not validacion:
        st.warning("‚ö†Ô∏è **Recomendaci√≥n**: Completa la **VALIDACI√ìN** antes de exportar")
    elif not validacion.get('es_valido'):
        st.error("‚ùå **Atenci√≥n**: El portafolio no ha pasado todas las validaciones")
    else:
        st.success("‚úÖ **Portafolio validado** - Listo para exportar")
    
    st.subheader("üìä Archivos de Exportaci√≥n")
    
    # Tabs de exportaci√≥n
    tab1, tab2, tab3, tab4 = st.tabs([
        "üìÑ CSV Quinielas",
        "üìã JSON Completo", 
        "üìù Reporte Texto",
        "üóÇÔ∏è Todos los Archivos"
    ])
    
    with tab1:
        st.markdown("**CSV con todas las quinielas para impresi√≥n**")
        
        # Regular
        quinielas_regular = resultado['quinielas_regular']
        csv_regular = exportar_csv_quinielas(quinielas_regular, "Regular")
        
        col1, col2 = st.columns(2)
        
        with col1:
            st.download_button(
                label="üìÑ Descargar Regular (CSV)",
                data=csv_regular,
                file_name=f"quinielas_regular_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv",
                mime="text/csv",
                type="primary"
            )
        
        # Revancha si existe
        if 'quinielas_revancha' in resultado:
            quinielas_revancha = resultado['quinielas_revancha']
            csv_revancha = exportar_csv_quinielas(quinielas_revancha, "Revancha")
            
            with col2:
                st.download_button(
                    label="üìÑ Descargar Revancha (CSV)",
                    data=csv_revancha,
                    file_name=f"quinielas_revancha_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv",
                    mime="text/csv"
                )
        
        # Preview del CSV
        st.markdown("**Preview del CSV:**")
        df_preview = pd.read_csv(BytesIO(csv_regular.encode()))
        st.dataframe(df_preview.head(10), use_container_width=True)
    
    with tab2:
        st.markdown("**JSON completo con toda la informaci√≥n**")
        
        json_completo = exportar_json_completo(resultado, validacion)
        
        st.download_button(
            label="üìã Descargar JSON Completo",
            data=json_completo,
            file_name=f"progol_completo_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json",
            mime="application/json",
            type="primary"
        )
        
        # Preview del JSON
        st.markdown("**Preview del JSON:**")
        json_data = json.loads(json_completo)
        st.json({k: v for k, v in list(json_data.items())[:2]})  # Solo primeras 2 claves
    
    with tab3:
        st.markdown("**Reporte detallado en formato texto**")
        
        reporte_texto = crear_reporte_completo(resultado, validacion)
        
        st.download_button(
            label="üìù Descargar Reporte (TXT)",
            data=reporte_texto,
            file_name=f"reporte_progol_{datetime.now().strftime('%Y%m%d_%H%M%S')}.txt",
            mime="text/plain",
            type="primary"
        )
        
        # Preview del reporte
        st.markdown("**Preview del Reporte:**")
        st.text_area("", reporte_texto[:1000] + "...", height=300, disabled=True)
    
    with tab4:
        st.markdown("**Descarga masiva de todos los archivos**")
        
        # Crear zip con todos los archivos
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        
        archivos = {
            f"quinielas_regular_{timestamp}.csv": csv_regular,
            f"progol_completo_{timestamp}.json": json_completo,
            f"reporte_progol_{timestamp}.txt": reporte_texto
        }
        
        # Si hay revancha, agregar
        if 'quinielas_revancha' in resultado:
            csv_revancha = exportar_csv_quinielas(resultado['quinielas_revancha'], "Revancha")
            archivos[f"quinielas_revancha_{timestamp}.csv"] = csv_revancha
        
        st.info(f"""
        **Archivos incluidos:**
        - CSV Regular ({len(resultado['quinielas_regular'])} quinielas)
        - JSON Completo (datos + validaci√≥n)
        - Reporte TXT (an√°lisis detallado)
        {f"- CSV Revancha ({len(resultado.get('quinielas_revancha', []))} quinielas)" if 'quinielas_revancha' in resultado else ""}
        """)
        
        # Lista de archivos
        for nombre, contenido in archivos.items():
            size_kb = len(contenido.encode()) / 1024
            st.write(f"üìÑ `{nombre}` ({size_kb:.1f} KB)")
        
        # Informaci√≥n de uso
        with st.expander("üí° Informaci√≥n de Uso"):
            st.markdown("""
            **C√≥mo usar los archivos:**
            
            1. **CSV Quinielas**: Para imprimir directamente las quinielas
            2. **JSON Completo**: Para an√°lisis posterior o integraci√≥n con otras herramientas
            3. **Reporte TXT**: Para revisi√≥n humana y documentaci√≥n
            
            **Recomendaciones:**
            - Verificar que el portafolio est√© validado antes de imprimir
            - Guardar el JSON para an√°lisis posteriores
            - Compartir el reporte TXT con el equipo
            """)
    
    # Resumen final
    st.subheader("üìä Resumen de Exportaci√≥n")
    
    col1, col2, col3, col4 = st.columns(4)
    
    with col1:
        st.metric("Quinielas Regular", len(resultado['quinielas_regular']))
    
    with col2:
        if 'quinielas_revancha' in resultado:
            st.metric("Quinielas Revancha", len(resultado['quinielas_revancha']))
        else:
            st.metric("Quinielas Revancha", "No generadas")
    
    with col3:
        anclas = resultado['resumen']['anclas_detectadas']
        st.metric("Anclas Usadas", anclas)
    
    with col4:
        if validacion:
            estado = "V√°lido" if validacion['es_valido'] else validacion['reglas_cumplidas']
            st.metric("Estado Validaci√≥n", estado)
        else:
            st.metric("Estado Validaci√≥n", "No validado")
    
    # Informaci√≥n final
    st.markdown("---")
    st.info(f"""
    üèÜ **PROGOL DEFINITIVO v{PROGOL_CONFIG['APP_VERSION']}** - Exportaci√≥n completada
    
    üìÖ Generado: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}  
    üéØ Metodolog√≠a: {PROGOL_CONFIG['METODOLOGIA']}  
    ‚öΩ Concurso: {resultado['partidos_regular'][0]['concurso_id']}
    
    **¬°Listo para jugar por el premio mayor!** üéâ
    """)

# ===========================
# PUNTO DE ENTRADA PRINCIPAL
# ===========================

if __name__ == "__main__":
    # Configurar logging
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )
    
    # Ejecutar aplicaci√≥n principal
    main()